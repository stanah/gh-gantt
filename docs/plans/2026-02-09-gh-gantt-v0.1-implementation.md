# gh-gantt v0.1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a gh CLI extension that syncs GitHub Projects issues to local JSON and displays them in a tree + gantt integrated browser UI with editing capabilities.

**Architecture:** Monorepo with 3 packages (shared, cli, ui). CLI handles GitHub API sync and serves the UI. UI is a React + D3.js SPA communicating with CLI via REST API. gh extension wrapper script invokes the CLI binary.

**Tech Stack:** TypeScript, pnpm workspace, zod, Commander.js, @octokit/graphql, React, D3.js (d3-scale, d3-time, d3-shape, d3-drag), Vite, tsup

---

## Task 1: Monorepo Scaffolding

**Files:**
- Create: `package.json` (root)
- Create: `pnpm-workspace.yaml`
- Create: `tsconfig.base.json`
- Create: `.gitignore`
- Create: `.npmrc`
- Create: `packages/shared/package.json`
- Create: `packages/shared/tsconfig.json`
- Create: `packages/cli/package.json`
- Create: `packages/cli/tsconfig.json`
- Create: `packages/ui/package.json`
- Create: `packages/ui/tsconfig.json`
- Create: `packages/ui/vite.config.ts`
- Create: `gh-gantt` (extension entry point shell script)
- Create: `LICENSE`

**Step 1: Create root package.json**

```json
{
  "name": "gh-gantt",
  "version": "0.1.0",
  "private": true,
  "description": "GitHub Projects Gantt chart with hierarchical progress tracking",
  "license": "MIT",
  "scripts": {
    "build": "pnpm -r build",
    "dev": "pnpm -r --parallel dev",
    "lint": "pnpm -r lint",
    "test": "pnpm -r test",
    "typecheck": "pnpm -r typecheck"
  },
  "engines": {
    "node": ">=20"
  }
}
```

**Step 2: Create pnpm-workspace.yaml**

```yaml
packages:
  - "packages/*"
```

**Step 3: Create tsconfig.base.json**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2022"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist"
  }
}
```

**Step 4: Create .gitignore**

```
node_modules/
dist/
.gantt-sync/
*.tsbuildinfo
.DS_Store
```

**Step 5: Create .npmrc**

```
shamefully-hoist=false
strict-peer-dependencies=false
```

**Step 6: Create packages/shared/package.json**

```json
{
  "name": "@gh-gantt/shared",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsup src/index.ts --format esm --dts",
    "dev": "tsup src/index.ts --format esm --dts --watch",
    "test": "vitest run",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "zod": "^3.23.0"
  },
  "devDependencies": {
    "tsup": "^8.0.0",
    "typescript": "^5.5.0",
    "vitest": "^2.0.0"
  }
}
```

**Step 7: Create packages/shared/tsconfig.json**

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}
```

**Step 8: Create packages/cli/package.json**

```json
{
  "name": "@gh-gantt/cli",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "bin": {
    "gh-gantt": "./dist/index.js"
  },
  "scripts": {
    "build": "tsup src/index.ts --format esm --dts",
    "dev": "tsup src/index.ts --format esm --watch",
    "test": "vitest run",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@gh-gantt/shared": "workspace:*",
    "@octokit/graphql": "^8.0.0",
    "commander": "^12.0.0",
    "express": "^4.21.0",
    "zod": "^3.23.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.0",
    "tsup": "^8.0.0",
    "typescript": "^5.5.0",
    "vitest": "^2.0.0"
  }
}
```

**Step 9: Create packages/cli/tsconfig.json**

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}
```

**Step 10: Create packages/ui/package.json**

```json
{
  "name": "@gh-gantt/ui",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "vite build",
    "dev": "vite",
    "preview": "vite preview",
    "test": "vitest run",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "d3-drag": "^3.0.0",
    "d3-scale": "^4.0.0",
    "d3-selection": "^3.0.0",
    "d3-shape": "^3.2.0",
    "d3-time": "^3.1.0",
    "react": "^18.3.0",
    "react-dom": "^18.3.0"
  },
  "devDependencies": {
    "@types/d3-drag": "^3.0.0",
    "@types/d3-scale": "^4.0.0",
    "@types/d3-selection": "^3.0.0",
    "@types/d3-shape": "^3.2.0",
    "@types/d3-time": "^3.0.0",
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.0",
    "typescript": "^5.5.0",
    "vite": "^5.4.0",
    "vitest": "^2.0.0"
  }
}
```

**Step 11: Create packages/ui/tsconfig.json**

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "jsx": "react-jsx",
    "outDir": "dist",
    "rootDir": "src",
    "lib": ["ES2022", "DOM", "DOM.Iterable"]
  },
  "include": ["src"]
}
```

**Step 12: Create packages/ui/vite.config.ts**

```ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/api": "http://localhost:3001",
    },
  },
});
```

**Step 13: Create gh-gantt shell script (extension entry point)**

```bash
#!/usr/bin/env bash
set -e
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
exec node "${SCRIPT_DIR}/packages/cli/dist/index.js" "$@"
```

**Step 14: Create LICENSE (MIT)**

**Step 15: Run pnpm install**

Run: `pnpm install`
Expected: Dependencies installed, lockfile created

**Step 16: Verify monorepo structure**

Run: `pnpm -r ls --depth 0`
Expected: 3 packages listed (@gh-gantt/shared, @gh-gantt/cli, @gh-gantt/ui)

**Step 17: Commit**

```bash
git add -A
git commit -m "feat: scaffold monorepo with shared, cli, and ui packages"
```

---

## Task 2: Shared Types & Zod Schemas

**Files:**
- Create: `packages/shared/src/index.ts`
- Create: `packages/shared/src/types.ts`
- Create: `packages/shared/src/schema.ts`
- Create: `packages/shared/src/constants.ts`
- Test: `packages/shared/src/__tests__/schema.test.ts`

**Step 1: Write the failing test for config schema**

```ts
// packages/shared/src/__tests__/schema.test.ts
import { describe, it, expect } from "vitest";
import { ConfigSchema } from "../schema.js";

describe("ConfigSchema", () => {
  it("validates a minimal valid config", () => {
    const config = {
      version: "1",
      project: {
        name: "test",
        github: { owner: "stanah", repo: "my-repo", project_number: 1 },
      },
      sync: {
        conflict_strategy: "remote-wins",
        auto_create_issues: false,
        field_mapping: { start_date: "Start Date", end_date: "End Date", status: "Status" },
      },
      task_types: {
        task: { label: "Task", display: "bar", color: "#27AE60", github_label: null },
      },
      type_hierarchy: { task: [] },
      statuses: {
        field_name: "Status",
        values: {
          Done: { color: "#2ECC71", done: true },
          Todo: { color: "#3498DB", done: false },
        },
      },
      gantt: {
        default_view: "month",
        working_days: [1, 2, 3, 4, 5],
        colors: { critical_path: "#E74C3C", on_track: "#2ECC71", at_risk: "#F39C12", overdue: "#E74C3C" },
      },
    };
    expect(ConfigSchema.parse(config)).toBeDefined();
  });

  it("rejects config with invalid display type", () => {
    const config = {
      version: "1",
      project: { name: "test", github: { owner: "o", repo: "r", project_number: 1 } },
      sync: { conflict_strategy: "remote-wins", auto_create_issues: false, field_mapping: { start_date: "S", end_date: "E", status: "St" } },
      task_types: { task: { label: "Task", display: "invalid", color: "#000", github_label: null } },
      type_hierarchy: { task: [] },
      statuses: { field_name: "Status", values: {} },
      gantt: { default_view: "month", working_days: [1], colors: { critical_path: "#000", on_track: "#000", at_risk: "#000", overdue: "#000" } },
    };
    expect(() => ConfigSchema.parse(config)).toThrow();
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd packages/shared && pnpm test`
Expected: FAIL — module not found

**Step 3: Write types.ts**

```ts
// packages/shared/src/types.ts
export type TaskDisplay = "bar" | "summary" | "milestone";
export type DependencyType = "finish-to-start" | "finish-to-finish" | "start-to-start" | "start-to-finish";
export type ConflictStrategy = "remote-wins" | "local-wins" | "manual";
export type ViewScale = "day" | "week" | "month" | "quarter";

export interface TaskType {
  label: string;
  display: TaskDisplay;
  color: string;
  github_label: string | null;
  default_collapsed?: boolean;
}

export interface StatusValue {
  color: string;
  done: boolean;
}

export interface Statuses {
  field_name: string;
  values: Record<string, StatusValue>;
}

export interface Dependency {
  task: string;
  type: DependencyType;
  lag: number;
}

export interface Task {
  id: string;
  type: string;
  github_issue: number | null;
  github_repo: string;
  parent: string | null;
  sub_tasks: string[];

  title: string;
  body: string | null;
  state: "open" | "closed";
  state_reason: string | null;
  assignees: string[];
  labels: string[];
  milestone: string | null;
  linked_prs: number[];
  created_at: string;
  updated_at: string;
  closed_at: string | null;

  custom_fields: Record<string, unknown>;

  start_date: string | null;
  end_date: string | null;
  date: string | null;
  blocked_by: Dependency[];
}

export interface TasksFile {
  tasks: Task[];
  cache: {
    comments: Record<string, Array<{ author: string; body: string; created_at: string }>>;
    reactions: Record<string, Record<string, number>>;
  };
}

export interface GithubConfig {
  owner: string;
  repo: string;
  project_number: number;
}

export interface SyncConfig {
  conflict_strategy: ConflictStrategy;
  auto_create_issues: boolean;
  field_mapping: {
    start_date: string;
    end_date: string;
    status: string;
  };
}

export interface GanttColors {
  critical_path: string;
  on_track: string;
  at_risk: string;
  overdue: string;
}

export interface GanttConfig {
  default_view: ViewScale;
  working_days: number[];
  colors: GanttColors;
}

export interface Config {
  version: string;
  project: {
    name: string;
    github: GithubConfig;
  };
  sync: SyncConfig;
  task_types: Record<string, TaskType>;
  type_hierarchy: Record<string, string[]>;
  statuses: Statuses;
  gantt: GanttConfig;
}

export interface IdMapping {
  issue_number: number;
  issue_node_id: string;
  project_item_id: string;
}

export interface Snapshot {
  hash: string;
  synced_at: string;
}

export interface SyncState {
  last_synced_at: string;
  project_node_id: string;
  id_map: Record<string, IdMapping>;
  field_ids: Record<string, string>;
  snapshots: Record<string, Snapshot>;
}
```

**Step 4: Write schema.ts**

```ts
// packages/shared/src/schema.ts
import { z } from "zod";

const TaskDisplaySchema = z.enum(["bar", "summary", "milestone"]);
const DependencyTypeSchema = z.enum(["finish-to-start", "finish-to-finish", "start-to-start", "start-to-finish"]);
const ConflictStrategySchema = z.enum(["remote-wins", "local-wins", "manual"]);
const ViewScaleSchema = z.enum(["day", "week", "month", "quarter"]);

const TaskTypeSchema = z.object({
  label: z.string(),
  display: TaskDisplaySchema,
  color: z.string(),
  github_label: z.string().nullable(),
  default_collapsed: z.boolean().optional(),
});

const StatusValueSchema = z.object({
  color: z.string(),
  done: z.boolean(),
});

const StatusesSchema = z.object({
  field_name: z.string(),
  values: z.record(StatusValueSchema),
});

const DependencySchema = z.object({
  task: z.string(),
  type: DependencyTypeSchema,
  lag: z.number(),
});

const TaskSchema = z.object({
  id: z.string(),
  type: z.string(),
  github_issue: z.number().nullable(),
  github_repo: z.string(),
  parent: z.string().nullable(),
  sub_tasks: z.array(z.string()),
  title: z.string(),
  body: z.string().nullable(),
  state: z.enum(["open", "closed"]),
  state_reason: z.string().nullable(),
  assignees: z.array(z.string()),
  labels: z.array(z.string()),
  milestone: z.string().nullable(),
  linked_prs: z.array(z.number()),
  created_at: z.string(),
  updated_at: z.string(),
  closed_at: z.string().nullable(),
  custom_fields: z.record(z.unknown()),
  start_date: z.string().nullable(),
  end_date: z.string().nullable(),
  date: z.string().nullable(),
  blocked_by: z.array(DependencySchema),
});

export const ConfigSchema = z.object({
  version: z.string(),
  project: z.object({
    name: z.string(),
    github: z.object({
      owner: z.string(),
      repo: z.string(),
      project_number: z.number(),
    }),
  }),
  sync: z.object({
    conflict_strategy: ConflictStrategySchema,
    auto_create_issues: z.boolean(),
    field_mapping: z.object({
      start_date: z.string(),
      end_date: z.string(),
      status: z.string(),
    }),
  }),
  task_types: z.record(TaskTypeSchema),
  type_hierarchy: z.record(z.array(z.string())),
  statuses: StatusesSchema,
  gantt: z.object({
    default_view: ViewScaleSchema,
    working_days: z.array(z.number()),
    colors: z.object({
      critical_path: z.string(),
      on_track: z.string(),
      at_risk: z.string(),
      overdue: z.string(),
    }),
  }),
});

export const TasksFileSchema = z.object({
  tasks: z.array(TaskSchema),
  cache: z.object({
    comments: z.record(z.array(z.object({
      author: z.string(),
      body: z.string(),
      created_at: z.string(),
    }))),
    reactions: z.record(z.record(z.number())),
  }),
});

export const SyncStateSchema = z.object({
  last_synced_at: z.string(),
  project_node_id: z.string(),
  id_map: z.record(z.object({
    issue_number: z.number(),
    issue_node_id: z.string(),
    project_item_id: z.string(),
  })),
  field_ids: z.record(z.string()),
  snapshots: z.record(z.object({
    hash: z.string(),
    synced_at: z.string(),
  })),
});

export { TaskSchema, DependencySchema, StatusesSchema };
```

**Step 5: Write constants.ts**

```ts
// packages/shared/src/constants.ts
export const GANTT_DIR = ".gantt-sync";
export const TASKS_FILE = "tasks.json";
export const SYNC_STATE_FILE = "sync-state.json";
export const CONFIG_FILE = "gantt.config.json";
export const DEFAULT_PORT = 3000;
export const API_PORT_OFFSET = 1;
```

**Step 6: Write index.ts (barrel export)**

```ts
// packages/shared/src/index.ts
export * from "./types.js";
export * from "./schema.js";
export * from "./constants.js";
```

**Step 7: Run tests to verify they pass**

Run: `cd packages/shared && pnpm build && pnpm test`
Expected: PASS

**Step 8: Commit**

```bash
git add packages/shared/
git commit -m "feat: add shared types, zod schemas, and constants"
```

---

## Task 3: CLI Store Layer

**Files:**
- Create: `packages/cli/src/store/config.ts`
- Create: `packages/cli/src/store/tasks.ts`
- Create: `packages/cli/src/store/state.ts`
- Test: `packages/cli/src/__tests__/store.test.ts`

**Step 1: Write failing tests for store**

```ts
// packages/cli/src/__tests__/store.test.ts
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { mkdtemp, rm } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { ConfigStore } from "../store/config.js";
import { TasksStore } from "../store/tasks.js";

describe("ConfigStore", () => {
  let dir: string;

  beforeEach(async () => {
    dir = await mkdtemp(join(tmpdir(), "gh-gantt-test-"));
  });

  afterEach(async () => {
    await rm(dir, { recursive: true });
  });

  it("writes and reads config", async () => {
    const store = new ConfigStore(dir);
    const config = {
      version: "1",
      project: { name: "test", github: { owner: "o", repo: "r", project_number: 1 } },
      sync: { conflict_strategy: "remote-wins" as const, auto_create_issues: false, field_mapping: { start_date: "S", end_date: "E", status: "St" } },
      task_types: { task: { label: "Task", display: "bar" as const, color: "#000", github_label: null } },
      type_hierarchy: { task: [] },
      statuses: { field_name: "Status", values: { Done: { color: "#0f0", done: true } } },
      gantt: { default_view: "month" as const, working_days: [1, 2, 3, 4, 5], colors: { critical_path: "#f00", on_track: "#0f0", at_risk: "#ff0", overdue: "#f00" } },
    };
    await store.write(config);
    const loaded = await store.read();
    expect(loaded.project.name).toBe("test");
  });

  it("throws when config does not exist", async () => {
    const store = new ConfigStore(dir);
    await expect(store.read()).rejects.toThrow();
  });
});

describe("TasksStore", () => {
  let dir: string;

  beforeEach(async () => {
    dir = await mkdtemp(join(tmpdir(), "gh-gantt-test-"));
  });

  afterEach(async () => {
    await rm(dir, { recursive: true });
  });

  it("writes and reads tasks file", async () => {
    const store = new TasksStore(dir);
    const tasksFile = {
      tasks: [{
        id: "t1", type: "task", github_issue: 1, github_repo: "o/r",
        parent: null, sub_tasks: [], title: "Test", body: null,
        state: "open" as const, state_reason: null, assignees: [], labels: [],
        milestone: null, linked_prs: [], created_at: "2026-01-01T00:00:00Z",
        updated_at: "2026-01-01T00:00:00Z", closed_at: null,
        custom_fields: {}, start_date: "2026-01-01", end_date: "2026-01-10",
        date: null, blocked_by: [],
      }],
      cache: { comments: {}, reactions: {} },
    };
    await store.write(tasksFile);
    const loaded = await store.read();
    expect(loaded.tasks).toHaveLength(1);
    expect(loaded.tasks[0].title).toBe("Test");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd packages/cli && pnpm test`
Expected: FAIL — modules not found

**Step 3: Implement store modules**

```ts
// packages/cli/src/store/config.ts
import { readFile, writeFile, mkdir } from "node:fs/promises";
import { join } from "node:path";
import { ConfigSchema, GANTT_DIR, CONFIG_FILE } from "@gh-gantt/shared";
import type { Config } from "@gh-gantt/shared";

export class ConfigStore {
  private path: string;

  constructor(projectRoot: string) {
    this.path = join(projectRoot, GANTT_DIR, CONFIG_FILE);
  }

  async read(): Promise<Config> {
    const raw = await readFile(this.path, "utf-8");
    return ConfigSchema.parse(JSON.parse(raw));
  }

  async write(config: Config): Promise<void> {
    await mkdir(join(this.path, ".."), { recursive: true });
    await writeFile(this.path, JSON.stringify(config, null, 2) + "\n");
  }

  async exists(): Promise<boolean> {
    try {
      await readFile(this.path);
      return true;
    } catch {
      return false;
    }
  }
}
```

```ts
// packages/cli/src/store/tasks.ts
import { readFile, writeFile, mkdir } from "node:fs/promises";
import { join } from "node:path";
import { TasksFileSchema, GANTT_DIR, TASKS_FILE } from "@gh-gantt/shared";
import type { TasksFile } from "@gh-gantt/shared";

export class TasksStore {
  private path: string;

  constructor(projectRoot: string) {
    this.path = join(projectRoot, GANTT_DIR, TASKS_FILE);
  }

  async read(): Promise<TasksFile> {
    const raw = await readFile(this.path, "utf-8");
    return TasksFileSchema.parse(JSON.parse(raw));
  }

  async write(data: TasksFile): Promise<void> {
    await mkdir(join(this.path, ".."), { recursive: true });
    await writeFile(this.path, JSON.stringify(data, null, 2) + "\n");
  }
}
```

```ts
// packages/cli/src/store/state.ts
import { readFile, writeFile, mkdir } from "node:fs/promises";
import { join } from "node:path";
import { SyncStateSchema, GANTT_DIR, SYNC_STATE_FILE } from "@gh-gantt/shared";
import type { SyncState } from "@gh-gantt/shared";

export class SyncStateStore {
  private path: string;

  constructor(projectRoot: string) {
    this.path = join(projectRoot, GANTT_DIR, SYNC_STATE_FILE);
  }

  async read(): Promise<SyncState> {
    const raw = await readFile(this.path, "utf-8");
    return SyncStateSchema.parse(JSON.parse(raw));
  }

  async write(data: SyncState): Promise<void> {
    await mkdir(join(this.path, ".."), { recursive: true });
    await writeFile(this.path, JSON.stringify(data, null, 2) + "\n");
  }
}
```

**Step 4: Run tests to verify they pass**

Run: `cd packages/shared && pnpm build && cd ../cli && pnpm test`
Expected: PASS

**Step 5: Commit**

```bash
git add packages/cli/src/store/ packages/cli/src/__tests__/
git commit -m "feat: add config, tasks, and sync-state store layer"
```

---

## Task 4: GitHub GraphQL Client & Auth

**Files:**
- Create: `packages/cli/src/github/client.ts`
- Create: `packages/cli/src/github/auth.ts`
- Test: `packages/cli/src/__tests__/auth.test.ts`

**Step 1: Write failing test for auth**

```ts
// packages/cli/src/__tests__/auth.test.ts
import { describe, it, expect, vi } from "vitest";
import { getToken } from "../github/auth.js";

describe("getToken", () => {
  it("returns token from gh auth token", async () => {
    // This test verifies the function exists and has correct signature
    expect(typeof getToken).toBe("function");
  });
});
```

**Step 2: Implement auth.ts**

```ts
// packages/cli/src/github/auth.ts
import { execFile } from "node:child_process";
import { promisify } from "node:util";

const execFileAsync = promisify(execFile);

export async function getToken(): Promise<string> {
  const { stdout } = await execFileAsync("gh", ["auth", "token"]);
  return stdout.trim();
}
```

**Step 3: Implement client.ts**

```ts
// packages/cli/src/github/client.ts
import { graphql } from "@octokit/graphql";
import { getToken } from "./auth.js";

export async function createGraphQLClient() {
  const token = await getToken();
  return graphql.defaults({
    headers: { authorization: `token ${token}` },
  });
}
```

**Step 4: Run tests**

Run: `cd packages/cli && pnpm test`
Expected: PASS

**Step 5: Commit**

```bash
git add packages/cli/src/github/
git commit -m "feat: add GitHub auth and GraphQL client"
```

---

## Task 5: GitHub ProjectV2 Queries

**Files:**
- Create: `packages/cli/src/github/queries.ts`
- Create: `packages/cli/src/github/projects.ts`
- Create: `packages/cli/src/github/issues.ts`
- Create: `packages/cli/src/github/sub-issues.ts`

**Step 1: Write GraphQL queries**

```ts
// packages/cli/src/github/queries.ts
export const PROJECT_QUERY = `
  query($owner: String!, $number: Int!) {
    user(login: $owner) {
      projectV2(number: $number) {
        id
        title
        fields(first: 50) {
          nodes {
            ... on ProjectV2SingleSelectField {
              id
              name
              options { id name }
            }
            ... on ProjectV2Field {
              id
              name
            }
            ... on ProjectV2IterationField {
              id
              name
            }
          }
        }
        items(first: 100, after: $cursor) {
          pageInfo { hasNextPage endCursor }
          nodes {
            id
            fieldValues(first: 20) {
              nodes {
                ... on ProjectV2ItemFieldSingleSelectValue {
                  field { ... on ProjectV2SingleSelectField { name } }
                  name
                }
                ... on ProjectV2ItemFieldTextValue {
                  field { ... on ProjectV2Field { name } }
                  text
                }
                ... on ProjectV2ItemFieldDateValue {
                  field { ... on ProjectV2Field { name } }
                  date
                }
                ... on ProjectV2ItemFieldNumberValue {
                  field { ... on ProjectV2Field { name } }
                  number
                }
                ... on ProjectV2ItemFieldIterationValue {
                  field { ... on ProjectV2IterationField { name } }
                  title
                }
              }
            }
            content {
              ... on Issue {
                number
                title
                body
                state
                stateReason
                assignees(first: 10) { nodes { login } }
                labels(first: 20) { nodes { name } }
                milestone { title }
                createdAt
                updatedAt
                closedAt
                repository { nameWithOwner }
              }
            }
          }
        }
      }
    }
  }
`;

export const SUB_ISSUES_QUERY = `
  query($owner: String!, $repo: String!, $number: Int!) {
    repository(owner: $owner, name: $repo) {
      issue(number: $number) {
        subIssues(first: 50) {
          nodes {
            number
            repository { nameWithOwner }
          }
        }
      }
    }
  }
`;
```

**Step 2: Implement projects.ts (fetches all project items with pagination)**

```ts
// packages/cli/src/github/projects.ts
import type { graphql } from "@octokit/graphql";
import { PROJECT_QUERY } from "./queries.js";

export interface RawProjectItem {
  id: string;
  fieldValues: Record<string, unknown>;
  content: {
    number: number;
    title: string;
    body: string | null;
    state: string;
    stateReason: string | null;
    assignees: string[];
    labels: string[];
    milestone: string | null;
    createdAt: string;
    updatedAt: string;
    closedAt: string | null;
    repository: string;
  } | null;
}

export interface RawProjectData {
  projectNodeId: string;
  projectTitle: string;
  fields: Array<{ id: string; name: string; options?: Array<{ id: string; name: string }> }>;
  items: RawProjectItem[];
}

export async function fetchProject(
  gql: typeof graphql,
  owner: string,
  projectNumber: number,
): Promise<RawProjectData> {
  const items: RawProjectItem[] = [];
  let cursor: string | null = null;
  let projectNodeId = "";
  let projectTitle = "";
  let fields: RawProjectData["fields"] = [];

  do {
    const result: any = await gql(PROJECT_QUERY, { owner, number: projectNumber, cursor });
    const project = result.user.projectV2;
    projectNodeId = project.id;
    projectTitle = project.title;
    fields = project.fields.nodes;

    for (const item of project.items.nodes) {
      if (!item.content) continue;
      const content = item.content;
      const fieldMap: Record<string, unknown> = {};
      for (const fv of item.fieldValues.nodes) {
        if (fv.field?.name) {
          fieldMap[fv.field.name] = fv.name ?? fv.text ?? fv.date ?? fv.number ?? fv.title;
        }
      }
      items.push({
        id: item.id,
        fieldValues: fieldMap,
        content: {
          number: content.number,
          title: content.title,
          body: content.body,
          state: content.state.toLowerCase(),
          stateReason: content.stateReason,
          assignees: content.assignees.nodes.map((a: any) => a.login),
          labels: content.labels.nodes.map((l: any) => l.name),
          milestone: content.milestone?.title ?? null,
          createdAt: content.createdAt,
          updatedAt: content.updatedAt,
          closedAt: content.closedAt,
          repository: content.repository.nameWithOwner,
        },
      });
    }

    cursor = project.items.pageInfo.hasNextPage ? project.items.pageInfo.endCursor : null;
  } while (cursor);

  return { projectNodeId, projectTitle, fields, items };
}
```

**Step 3: Implement issues.ts and sub-issues.ts** (similar pattern — fetch sub-issue relationships)

**Step 4: Commit**

```bash
git add packages/cli/src/github/
git commit -m "feat: add ProjectV2 GraphQL queries and data fetching"
```

---

## Task 6: Type Resolver & Init Command

**Files:**
- Create: `packages/cli/src/sync/type-resolver.ts`
- Create: `packages/cli/src/commands/init.ts`
- Create: `packages/cli/src/index.ts`

**Step 1: Implement type-resolver.ts**

Resolves task type from GitHub labels using config's `task_types[].github_label` mapping.

**Step 2: Implement init command**

1. Accept `--owner`, `--repo`, `--project` flags
2. Call `fetchProject()` to get all data
3. Fetch sub-issues for parent/child relationships
4. Auto-detect Status field options → generate `statuses` config
5. Map labels → task types
6. Generate `gantt.config.json`, `tasks.json`, `sync-state.json`

**Step 3: Wire up CLI entry point (index.ts) with Commander.js**

```ts
// packages/cli/src/index.ts
#!/usr/bin/env node
import { Command } from "commander";
import { initCommand } from "./commands/init.js";

const program = new Command();
program.name("gh-gantt").version("0.1.0").description("GitHub Projects Gantt chart");
program.addCommand(initCommand);
program.parse();
```

**Step 4: Build and test manually**

Run: `pnpm build && node packages/cli/dist/index.js --help`
Expected: Help output with `init` subcommand

**Step 5: Commit**

```bash
git add packages/cli/src/
git commit -m "feat: add init command with ProjectV2 data fetching"
```

---

## Task 7: Pull Command & Snapshot Hashing

**Files:**
- Create: `packages/cli/src/commands/pull.ts`
- Create: `packages/cli/src/sync/hash.ts`
- Create: `packages/cli/src/sync/mapper.ts`
- Test: `packages/cli/src/__tests__/hash.test.ts`

**Step 1: Write failing test for hash**

Test that the same task data produces the same hash, and modified data produces a different hash.

**Step 2: Implement hash.ts**

Hash only bidirectional sync fields (title, body, state, assignees, labels, milestone, custom_fields, parent, sub_tasks).

**Step 3: Implement mapper.ts**

Maps between GitHub API response fields and local Task fields using `gantt.config.json`'s `field_mapping`.

**Step 4: Implement pull command**

1. Read config and sync-state
2. Fetch current project data from GitHub
3. For each remote item: compare hash with snapshot
4. Update tasks.json with remote changes
5. Update sync-state snapshots

**Step 5: Run tests and verify**

**Step 6: Commit**

```bash
git commit -m "feat: add pull command with snapshot-based diff detection"
```

---

## Task 8: Push Command & Status Command

**Files:**
- Create: `packages/cli/src/commands/push.ts`
- Create: `packages/cli/src/commands/status.ts`
- Create: `packages/cli/src/github/mutations.ts`
- Create: `packages/cli/src/sync/diff.ts`
- Create: `packages/cli/src/sync/conflict.ts`

**Step 1: Implement diff.ts**

Compare local tasks against snapshots to find local changes.

**Step 2: Implement conflict.ts**

Detect when both local and remote changed the same field. Return list of conflicts with field-level detail.

**Step 3: Implement mutations.ts**

GraphQL mutations for: update issue (title, body, state), update ProjectV2 item field values, add/remove sub-issues.

**Step 4: Implement push command**

1. Compute local diff (changed since last sync)
2. `--dry-run`: print diff and exit
3. For each changed task: apply mutations to GitHub
4. Update sync-state snapshots

**Step 5: Implement status command**

1. Compute local diff
2. Fetch remote and compute remote diff
3. Detect conflicts
4. Print formatted output (added/modified/deleted/conflicts)

**Step 6: Commit**

```bash
git commit -m "feat: add push and status commands with conflict detection"
```

---

## Task 9: Serve Command & REST API

**Files:**
- Create: `packages/cli/src/commands/serve.ts`
- Create: `packages/cli/src/server/api.ts`

**Step 1: Implement REST API (api.ts)**

```
GET  /api/config          → gantt.config.json
GET  /api/tasks           → tasks.json (with computed progress)
PATCH /api/tasks/:id      → update task fields in tasks.json
POST /api/sync/pull       → trigger pull
POST /api/sync/push       → trigger push
GET  /api/sync/status     → diff preview
```

**Step 2: Implement progress calculation middleware**

Add computed `_progress` field to each task in GET /api/tasks response. Recursively calculate from state + Status done flag.

**Step 3: Implement serve command**

1. Start Express API server on port+1
2. Start Vite dev server (or serve built UI) on port
3. Proxy /api from Vite to Express
4. `--sync-on-start`: run pull before serving

**Step 4: Verify `gh gantt serve` launches and /api/config returns data**

**Step 5: Commit**

```bash
git commit -m "feat: add serve command with REST API for UI"
```

---

## Task 10: UI Shell & Layout

**Files:**
- Create: `packages/ui/index.html`
- Create: `packages/ui/src/main.tsx`
- Create: `packages/ui/src/App.tsx`
- Create: `packages/ui/src/components/Layout.tsx`
- Create: `packages/ui/src/hooks/useApi.ts`
- Create: `packages/ui/src/types/index.ts`

**Step 1: Create React app entry point**

Basic Vite + React setup with index.html, main.tsx, App.tsx.

**Step 2: Implement useApi hook**

Fetches config and tasks from REST API. Returns loading/error/data state.

**Step 3: Implement Layout component**

Resizable split pane: left (task tree), right (gantt timeline). Use CSS flexbox + drag handle.

**Step 4: Verify UI loads in browser with mock data**

Run: `pnpm dev` (from root)
Expected: Browser shows split pane layout

**Step 5: Commit**

```bash
git commit -m "feat: add React UI shell with resizable split pane layout"
```

---

## Task 11: Task Tree Component (Left Pane)

**Files:**
- Create: `packages/ui/src/components/TaskTree.tsx`
- Create: `packages/ui/src/components/TaskRow.tsx`
- Create: `packages/ui/src/components/StatusBadge.tsx`
- Create: `packages/ui/src/components/ProgressBar.tsx`
- Create: `packages/ui/src/components/TypeFilter.tsx`
- Create: `packages/ui/src/hooks/useTaskTree.ts`
- Create: `packages/ui/src/hooks/useTypeFilter.ts`
- Create: `packages/ui/src/lib/progress.ts`
- Test: `packages/ui/src/__tests__/progress.test.ts`

**Step 1: Write failing test for progress calculation**

```ts
// packages/ui/src/__tests__/progress.test.ts
import { describe, it, expect } from "vitest";
import { calculateProgress } from "../lib/progress.js";

describe("calculateProgress", () => {
  it("returns 100 for closed task", () => {
    expect(calculateProgress({ state: "closed", sub_tasks: [] }, [], {})).toBe(100);
  });

  it("returns 100 for open task with done status", () => {
    const statuses = { Done: { color: "#0f0", done: true } };
    expect(calculateProgress(
      { state: "open", sub_tasks: [], custom_fields: { Status: "Done" } },
      [], statuses, "Status"
    )).toBe(100);
  });

  it("returns 0 for open task without done status", () => {
    expect(calculateProgress({ state: "open", sub_tasks: [] }, [], {})).toBe(0);
  });

  it("calculates parent progress from children", () => {
    const tasks = [
      { id: "t1", state: "closed", sub_tasks: [], custom_fields: {} },
      { id: "t2", state: "open", sub_tasks: [], custom_fields: {} },
    ];
    const parent = { state: "open", sub_tasks: ["t1", "t2"], custom_fields: {} };
    expect(calculateProgress(parent, tasks, {})).toBe(50);
  });
});
```

**Step 2: Implement progress.ts**

**Step 3: Implement useTaskTree hook**

Build tree structure from flat task array using parent/sub_tasks. Handle collapse/expand state.

**Step 4: Implement TaskTree, TaskRow, StatusBadge, ProgressBar components**

**Step 5: Implement TypeFilter (toggle task types on/off)**

**Step 6: Run tests and verify tree renders in browser**

**Step 7: Commit**

```bash
git commit -m "feat: add task tree with progress, status badges, and type filter"
```

---

## Task 12: Gantt Timeline (Right Pane)

**Files:**
- Create: `packages/ui/src/components/GanttChart.tsx`
- Create: `packages/ui/src/components/GanttTimeline.tsx`
- Create: `packages/ui/src/components/GanttGrid.tsx`
- Create: `packages/ui/src/components/GanttBar.tsx`
- Create: `packages/ui/src/components/GanttSummaryBar.tsx`
- Create: `packages/ui/src/components/GanttMilestone.tsx`
- Create: `packages/ui/src/hooks/useGanttScale.ts`
- Create: `packages/ui/src/lib/summary-calc.ts`
- Create: `packages/ui/src/lib/date-utils.ts`
- Test: `packages/ui/src/__tests__/summary-calc.test.ts`
- Test: `packages/ui/src/__tests__/date-utils.test.ts`

**Step 1: Write failing tests for summary-calc and date-utils**

Test summary bar date range calculation (min start, max end of children). Test working day helpers.

**Step 2: Implement date-utils.ts and summary-calc.ts**

**Step 3: Implement useGanttScale hook**

D3 scaleTime for x-axis. Manages view scale (day/week/month), zoom level, visible date range.

**Step 4: Implement GanttTimeline (date header), GanttGrid (background lines + non-working day shading + today line)**

**Step 5: Implement GanttBar (regular task bar colored by task_type)**

**Step 6: Implement GanttSummaryBar (bracket-style bar for parent tasks)**

**Step 7: Implement GanttMilestone (diamond marker)**

**Step 8: Implement GanttChart container (composes all gantt components, syncs vertical scroll with task tree)**

**Step 9: Verify in browser: tasks render as bars on timeline**

**Step 10: Commit**

```bash
git commit -m "feat: add gantt timeline with bar, summary, and milestone rendering"
```

---

## Task 13: Blocked-by Dependency Arrows

**Files:**
- Create: `packages/ui/src/components/GanttBlockLines.tsx`
- Create: `packages/ui/src/lib/dependency-graph.ts`
- Test: `packages/ui/src/__tests__/dependency-graph.test.ts`

**Step 1: Write failing test for dependency graph**

Test cycle detection. Test arrow path generation for FS/FF/SS/SF types.

**Step 2: Implement dependency-graph.ts**

DAG construction from blocked_by. Cycle detection (warn, don't crash). Path coordinate calculation for each dependency type.

**Step 3: Implement GanttBlockLines**

SVG paths with arrowhead markers. Color-code by type. Dashed line for lag > 0. Red highlight for cycles.

**Step 4: Verify arrows render between tasks in browser**

**Step 5: Commit**

```bash
git commit -m "feat: add blocked_by dependency arrows with cycle detection"
```

---

## Task 14: Gantt Bar Drag & Resize

**Files:**
- Create: `packages/ui/src/hooks/useDragResize.ts`
- Modify: `packages/ui/src/components/GanttBar.tsx`

**Step 1: Implement useDragResize hook**

Use d3-drag. Handle three interactions:
- Drag entire bar → move start_date and end_date
- Drag left edge → change start_date
- Drag right edge → change end_date

Snap to day boundaries. Call PATCH /api/tasks/:id on drag end.

**Step 2: Add drag handles to GanttBar**

Left and right resize handles (visible on hover). Full bar drag for move.

**Step 3: Verify drag works in browser**

**Step 4: Commit**

```bash
git commit -m "feat: add gantt bar drag and resize for date editing"
```

---

## Task 15: Task Detail Side Panel

**Files:**
- Create: `packages/ui/src/components/TaskDetailPanel.tsx`
- Create: `packages/ui/src/components/MarkdownEditor.tsx`
- Modify: `packages/ui/src/App.tsx`

**Step 1: Implement TaskDetailPanel**

Opens on task double-click. Sections:
- Title (editable inline)
- Status dropdown (from config statuses)
- State toggle (open/closed)
- Body (Markdown render + edit toggle)
- Assignees, Labels (tag-style selectors)
- Type selector
- Date pickers (start_date, end_date)
- Blocked_by / Blocking lists
- Parent / Sub-tasks list with edit
- Linked PRs (read-only)
- Comments (read-only, from cache)
- GitHub Issue link

**Step 2: Implement MarkdownEditor**

Simple textarea + preview toggle. No rich editor needed for v0.1.

**Step 3: Wire edits to PATCH /api/tasks/:id**

**Step 4: Verify panel opens and edits persist**

**Step 5: Commit**

```bash
git commit -m "feat: add task detail side panel with inline editing"
```

---

## Task 16: Toolbar & Zoom Controls

**Files:**
- Create: `packages/ui/src/components/Toolbar.tsx`
- Modify: `packages/ui/src/components/GanttChart.tsx`

**Step 1: Implement Toolbar**

- View scale buttons (day/week/month)
- Zoom in/out buttons
- "Today" button (scroll to today)
- Pull/Push buttons (call /api/sync/pull, /api/sync/push)
- Status indicator (last sync time)

**Step 2: Add mouse wheel zoom to GanttChart**

**Step 3: Commit**

```bash
git commit -m "feat: add toolbar with zoom, view scale, and sync controls"
```

---

## Task 17: gh Extension Packaging

**Files:**
- Modify: `gh-gantt` (entry script)
- Modify: `package.json` (root — add build:extension script)
- Create: `.github/workflows/release.yml` (optional)

**Step 1: Ensure `gh-gantt` script works after build**

```bash
pnpm build
chmod +x gh-gantt
./gh-gantt --help
```

**Step 2: Test local extension install**

```bash
gh extension install .
gh gantt --help
```

Expected: Help output

**Step 3: Test full flow**

```bash
gh gantt init --owner stanah --repo test-repo --project 1
gh gantt serve
# Open browser, verify tree + gantt renders
# Edit a task, push changes
gh gantt push --dry-run
```

**Step 4: Commit**

```bash
git commit -m "feat: package as gh CLI extension with local install support"
```

---

## Task Summary

| # | Task | Dependencies | Est. Complexity |
|---|------|-------------|-----------------|
| 1 | Monorepo Scaffolding | — | Low |
| 2 | Shared Types & Schemas | 1 | Low |
| 3 | CLI Store Layer | 2 | Low |
| 4 | GitHub GraphQL Client & Auth | 3 | Low |
| 5 | GitHub ProjectV2 Queries | 4 | Medium |
| 6 | Type Resolver & Init Command | 5 | Medium |
| 7 | Pull Command & Hashing | 6 | Medium |
| 8 | Push Command & Status | 7 | High |
| 9 | Serve Command & REST API | 3 | Medium |
| 10 | UI Shell & Layout | 9 | Low |
| 11 | Task Tree (Left Pane) | 10 | Medium |
| 12 | Gantt Timeline (Right Pane) | 10 | High |
| 13 | Dependency Arrows | 12 | Medium |
| 14 | Bar Drag & Resize | 12 | Medium |
| 15 | Task Detail Side Panel | 11 | High |
| 16 | Toolbar & Zoom | 12 | Low |
| 17 | gh Extension Packaging | all | Low |

**Parallelizable:** Tasks 9-16 (UI) can be worked on in parallel with Tasks 7-8 (sync) once Task 6 is complete, as they only share the REST API contract.
